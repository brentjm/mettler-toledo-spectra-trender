"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module node-opcua-address-space
 */
const async = require("async");
const _ = require("underscore");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_value_1 = require("node-opcua-data-value");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
const node_opcua_service_browse_1 = require("node-opcua-service-browse");
const node_opcua_service_call_1 = require("node-opcua-service-call");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const call_helpers_1 = require("./helpers/call_helpers");
const session_context_1 = require("./session_context");
/**
 * Pseudo session is an helper object that exposes the same async methods
 * than the ClientSession. It can be used on a server address space.
 *
 * Code reused !
 * The primary benefit of this object  is that its makes advanced OPCUA
 * operations that uses browse, translate, read, write etc similar
 * whether we work inside a server or through a client session.
 *
 * @param addressSpace {AddressSpace}
 * @constructor
 */
class PseudoSession {
    constructor(addressSpace, server, session) {
        this.addressSpace = addressSpace;
        this.server = server || {};
        this.session = session || {};
    }
    browse(nodesToBrowse, callback) {
        const isArray = _.isArray(nodesToBrowse);
        if (!isArray) {
            nodesToBrowse = [nodesToBrowse];
        }
        const results = [];
        for (let browseDescription of nodesToBrowse) {
            browseDescription.referenceTypeId = node_opcua_nodeid_1.resolveNodeId(browseDescription.referenceTypeId);
            browseDescription = new node_opcua_service_browse_1.BrowseDescription(browseDescription);
            const nodeId = node_opcua_nodeid_1.resolveNodeId(browseDescription.nodeId);
            const r = this.addressSpace.browseSingleNode(nodeId, browseDescription);
            results.push(r);
        }
        callback(null, isArray ? results : results[0]);
    }
    read(nodesToRead, callback) {
        const isArray = _.isArray(nodesToRead);
        if (!isArray) {
            nodesToRead = [nodesToRead];
        }
        // xx const context = new SessionContext({ session: null });
        const dataValues = nodesToRead.map((nodeToRead) => {
            node_opcua_assert_1.assert(!!nodeToRead.nodeId, "expecting a nodeId");
            node_opcua_assert_1.assert(!!nodeToRead.attributeId, "expecting a attributeId");
            const nodeId = nodeToRead.nodeId;
            const attributeId = nodeToRead.attributeId;
            const indexRange = nodeToRead.indexRange;
            const dataEncoding = nodeToRead.dataEncoding;
            const obj = this.addressSpace.findNode(nodeId);
            if (!obj) {
                return new node_opcua_data_value_1.DataValue({ statusCode: node_opcua_status_code_1.StatusCodes.BadNodeIdUnknown });
            }
            const context = session_context_1.SessionContext.defaultContext;
            const dataValue = obj.readAttribute(context, attributeId, indexRange, dataEncoding);
            return dataValue;
        });
        callback(null, isArray ? dataValues : dataValues[0]);
    }
    browseNext(...args) {
        throw new Error("Not Implemented");
    }
    call(methodsToCall, callback) {
        const isArray = _.isArray(methodsToCall);
        if (!isArray) {
            methodsToCall = [methodsToCall];
        }
        async.map(methodsToCall, (methodToCall, innerCallback) => {
            const callMethodRequest = new node_opcua_service_call_1.CallMethodRequest(methodToCall);
            call_helpers_1.callMethodHelper(this.server, this.session, this.addressSpace, callMethodRequest, (err, result) => {
                let callMethodResult;
                if (err) {
                    callMethodResult = new node_opcua_service_call_1.CallMethodResult({
                        statusCode: node_opcua_status_code_1.StatusCodes.BadInternalError
                    });
                }
                else {
                    callMethodResult = new node_opcua_service_call_1.CallMethodResult(result);
                }
                innerCallback(null, callMethodResult);
            });
        }, (err, callMethodResults) => {
            callback(null, isArray ? callMethodResults : callMethodResults[0]);
        });
    }
    getArgumentDefinition(methodId, callback) {
        return node_opcua_pseudo_session_1.getArgumentDefinitionHelper(this, methodId, callback);
    }
    translateBrowsePath(browsePaths, callback) {
        const isArray = _.isArray(browsePaths);
        if (!isArray) {
            browsePaths = [browsePaths];
        }
        // xx const context = new SessionContext({ session: null });
        const browsePathResults = browsePaths.map((browsePath) => {
            return this.addressSpace.browsePath(browsePath);
        });
        callback(null, isArray ? browsePathResults : browsePathResults[0]);
    }
}
exports.PseudoSession = PseudoSession;
// tslint:disable:no-var-requires
// tslint:disable:max-line-length
const thenify = require("thenify");
PseudoSession.prototype.read = thenify.withCallback(PseudoSession.prototype.read);
PseudoSession.prototype.browse = thenify.withCallback(PseudoSession.prototype.browse);
PseudoSession.prototype.browseNext = thenify.withCallback(PseudoSession.prototype.browseNext);
PseudoSession.prototype.getArgumentDefinition = thenify.withCallback(PseudoSession.prototype.getArgumentDefinition);
PseudoSession.prototype.call = thenify.withCallback(PseudoSession.prototype.call);
PseudoSession.prototype.translateBrowsePath = thenify.withCallback(PseudoSession.prototype.translateBrowsePath);
//# sourceMappingURL=pseudo_session.js.map