"use strict";
/**
 * @module node-opcua-factory
 */
// tslint:disable:no-console
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const _ = require("underscore");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_debug_1 = require("node-opcua-debug");
const factories_baseobject_1 = require("./factories_baseobject");
const debugLog = node_opcua_debug_1.make_debugLog(__filename);
const doDebug = node_opcua_debug_1.checkDebugFlag(__filename);
const constructorMap = {};
const _globalStructuredTypeConstructors = {};
function getStructureTypeConstructor(typeName) {
    return _globalStructuredTypeConstructors[typeName];
}
exports.getStructureTypeConstructor = getStructureTypeConstructor;
function hasStructuredType(typeName) {
    return !!_globalStructuredTypeConstructors[typeName];
}
exports.hasStructuredType = hasStructuredType;
function getStructuredTypeSchema(typeName) {
    const struct = _globalStructuredTypeConstructors[typeName];
    if (!struct) {
        throw new Error("cannot find structured type for " + typeName);
    }
    return struct.schema;
}
exports.getStructuredTypeSchema = getStructuredTypeSchema;
function registerFactory(typeName, constructor) {
    /* istanbul ignore next */
    if (getStructureTypeConstructor(typeName)) {
        console.log(getStructureTypeConstructor(typeName));
        throw new Error(" registerFactory  : " + typeName + " already registered");
    }
    _globalStructuredTypeConstructors[typeName] = constructor;
}
exports.registerFactory = registerFactory;
/* istanbul ignore next */
function dump() {
    console.log(" dumping registered factories");
    console.log(" Factory ", Object.keys(_globalStructuredTypeConstructors).sort().forEach((e) => e));
    console.log(" done");
}
exports.dump = dump;
function callConstructor(constructor) {
    node_opcua_assert_1.assert(_.isFunction(constructor));
    const constructorFunc = constructor.bind.apply(constructor, arguments);
    return new constructorFunc();
}
exports.callConstructor = callConstructor;
function getConstructor(expandedNodeId) {
    const expandedNodeIdKey = makeExpandedNodeIdKey(expandedNodeId);
    if (!(expandedNodeId && (expandedNodeIdKey in constructorMap))) {
        debugLog(chalk_1.default.red("#getConstructor : cannot find constructor for expandedId "), expandedNodeId.toString());
        return null;
    }
    return constructorMap[expandedNodeIdKey];
}
exports.getConstructor = getConstructor;
function hasConstructor(expandedNodeId) {
    if (!expandedNodeId) {
        return false;
    }
    /* istanbul ignore next */
    if (!verifyExpandedNodeId(expandedNodeId)) {
        console.log("Invalid expandedNodeId");
        return false;
    }
    const expandedNodeIdKey = makeExpandedNodeIdKey(expandedNodeId);
    return !!constructorMap[expandedNodeIdKey];
}
exports.hasConstructor = hasConstructor;
function constructObject(expandedNodeId) {
    if (!verifyExpandedNodeId(expandedNodeId)) {
        throw new Error(" constructObject : invalid expandedNodeId provided " + expandedNodeId.toString());
    }
    const constructor = getConstructor(expandedNodeId);
    if (!constructor) {
        debugLog("Cannot find constructor for " + expandedNodeId.toString());
        return new factories_baseobject_1.BaseUAObject();
        // throw new Error("Cannot find constructor for " + expandedNodeId.toString());
    }
    return callConstructor(constructor);
}
exports.constructObject = constructObject;
function verifyExpandedNodeId(expandedNodeId) {
    /* istanbul ignore next */
    if (expandedNodeId.value instanceof Buffer) {
        throw new Error("getConstructor not implemented for opaque nodeid");
    }
    if (expandedNodeId.namespace === 0) {
        if (expandedNodeId.namespaceUri === "http://opcfoundation.org/UA/" || !expandedNodeId.namespaceUri) {
            return true;
        }
        // When namespace is ZERO, namepaceUri must be "http://opcfoundation.org/UA/"  or nothing
        return false;
    }
    else {
        // expandedNodeId.namespace  !==0
        // in this case a valid expandedNodeId.namespaceUri  must be provided
        return !!expandedNodeId.namespaceUri && expandedNodeId.namespaceUri.length > 2;
    }
}
function makeExpandedNodeIdKey(expandedNodeId) {
    if (expandedNodeId.namespace === 0) {
        return expandedNodeId.value.toString();
    }
    return expandedNodeId.namespaceUri + "@" + expandedNodeId.value.toString();
}
function registerClassDefinition(className, classConstructor) {
    registerFactory(className, classConstructor);
    const expandedNodeId = classConstructor.encodingDefaultBinary;
    if (doDebug) {
        debugLog(" registering ", className, expandedNodeId.toString());
    }
    /* istanbul ignore next */
    if (!verifyExpandedNodeId(expandedNodeId)) {
        throw new Error("Invalid expandedNodeId");
    }
    const expandedNodeIdKey = makeExpandedNodeIdKey(expandedNodeId);
    /* istanbul ignore next */
    if (expandedNodeIdKey in constructorMap) {
        throw new Error(" Class " + className + " with ID " + expandedNodeId +
            "  already in constructorMap for  " + constructorMap[expandedNodeIdKey].name);
    }
    constructorMap[expandedNodeIdKey] = classConstructor;
}
exports.registerClassDefinition = registerClassDefinition;
//# sourceMappingURL=factories_factories.js.map